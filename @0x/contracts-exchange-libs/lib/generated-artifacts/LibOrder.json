{
    "schemaVersion": "2.0.0",
    "contractName": "LibOrder",
    "compilerOutput": {
        "abi": [
            {
                "constant": true,
                "inputs": [],
                "name": "EIP712_DOMAIN_HASH",
                "outputs": [
                    {
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            }
        ],
        "devdoc": {
            "methods": {}
        },
        "evm": {
            "bytecode": {
                "linkReferences": {},
                "object": "0x7f454950373132446f6d61696e280000000000000000000000000000000000000060a09081527f737472696e67206e616d652c000000000000000000000000000000000000000060ad527f737472696e672076657273696f6e2c000000000000000000000000000000000060b9527f6164647265737320766572696679696e67436f6e74726163740000000000000060c8527f290000000000000000000000000000000000000000000000000000000000000060e152604260808181529120600b60e2527f30782050726f746f636f6c000000000000000000000000000000000000000000610102526001610122527f3200000000000000000000000000000000000000000000000000000000000000610142526101829081527ff0f24618f4c4be1e62e026fb039a20ef96f4495294817d1027ffaa6d1f70e61e6101a2527fad7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a56101c252306101e252610162829052610202604052206000556080806101866000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e306f77914602d575b600080fd5b60336045565b60408051918252519081900360200190f35b6000548156fea265627a7a7230582034bfc50d69d01163ac1cecffe52c3db33d533785bba94fb87aeaae8dfe43857d64736f6c634300050a0032",
                "opcodes": "PUSH32 0x454950373132446F6D61696E2800000000000000000000000000000000000000 PUSH1 0xA0 SWAP1 DUP2 MSTORE PUSH32 0x737472696E67206E616D652C0000000000000000000000000000000000000000 PUSH1 0xAD MSTORE PUSH32 0x737472696E672076657273696F6E2C0000000000000000000000000000000000 PUSH1 0xB9 MSTORE PUSH32 0x6164647265737320766572696679696E67436F6E747261637400000000000000 PUSH1 0xC8 MSTORE PUSH32 0x2900000000000000000000000000000000000000000000000000000000000000 PUSH1 0xE1 MSTORE PUSH1 0x42 PUSH1 0x80 DUP2 DUP2 MSTORE SWAP2 KECCAK256 PUSH1 0xB PUSH1 0xE2 MSTORE PUSH32 0x30782050726F746F636F6C000000000000000000000000000000000000000000 PUSH2 0x102 MSTORE PUSH1 0x1 PUSH2 0x122 MSTORE PUSH32 0x3200000000000000000000000000000000000000000000000000000000000000 PUSH2 0x142 MSTORE PUSH2 0x182 SWAP1 DUP2 MSTORE PUSH32 0xF0F24618F4C4BE1E62E026FB039A20EF96F4495294817D1027FFAA6D1F70E61E PUSH2 0x1A2 MSTORE PUSH32 0xAD7C5BEF027816A800DA1736444FB58A807EF4C9603B7848673F7E3A68EB14A5 PUSH2 0x1C2 MSTORE ADDRESS PUSH2 0x1E2 MSTORE PUSH2 0x162 DUP3 SWAP1 MSTORE PUSH2 0x202 PUSH1 0x40 MSTORE KECCAK256 PUSH1 0x0 SSTORE PUSH1 0x80 DUP1 PUSH2 0x186 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x28 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xE306F779 EQ PUSH1 0x2D JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x33 PUSH1 0x45 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP2 DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH1 0x0 SLOAD DUP2 JUMP INVALID LOG2 PUSH6 0x627A7A723058 KECCAK256 CALLVALUE 0xbf 0xc5 0xd PUSH10 0xD01163AC1CECFFE52C3D 0xb3 RETURNDATASIZE MSTORE8 CALLDATACOPY DUP6 0xbb 0xa9 0x4f 0xb8 PUSH27 0xEAAE8DFE43857D64736F6C634300050A0032000000000000000000 ",
                "sourceMap": "1045:148:3:-;;;;;;;;;;;;;;;;;22:32:-1;633:5600:6;6:49:-1;;;1035:159:3;;1511:18;1045:148;1511:18;;;;1045:148;1511:18;1561:21;;;;1416:214;;;;1495:36;1416:214;;1545:39;1416:214;;1614:4;1416:214;;1561:21;6:49:-1;;;1416:214:3;633:5600:6;1416:214:3;1406:225;-1:-1:-1;1385:246:3;633:5600:6;;;;;;"
            },
            "deployedBytecode": {
                "linkReferences": {},
                "object": "0x6080604052348015600f57600080fd5b506004361060285760003560e01c8063e306f77914602d575b600080fd5b60336045565b60408051918252519081900360200190f35b6000548156fea265627a7a7230582034bfc50d69d01163ac1cecffe52c3db33d533785bba94fb87aeaae8dfe43857d64736f6c634300050a0032",
                "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x28 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xE306F779 EQ PUSH1 0x2D JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x33 PUSH1 0x45 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP2 DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH1 0x0 SLOAD DUP2 JUMP INVALID LOG2 PUSH6 0x627A7A723058 KECCAK256 CALLVALUE 0xbf 0xc5 0xd PUSH10 0xD01163AC1CECFFE52C3D 0xb3 RETURNDATASIZE MSTORE8 CALLDATACOPY DUP6 0xbb 0xa9 0x4f 0xb8 PUSH27 0xEAAE8DFE43857D64736F6C634300050A0032000000000000000000 ",
                "sourceMap": "633:5600:6:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;633:5600:6;;;;;;;;;;;;;;;;;;;1301:33:3;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;:::o"
            }
        }
    },
    "sources": {
        "src/LibOrder.sol": {
            "id": 6
        },
        "src/LibEIP712.sol": {
            "id": 3
        }
    },
    "sourceCodes": {
        "src/LibOrder.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\nimport \"./LibEIP712.sol\";\n\n\ncontract LibOrder is\n    LibEIP712\n{\n    // Hash for the EIP712 Order Schema\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \")\"\n    ));\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's state is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID,                     // Default value\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n        FILLABLE,                    // Order is fillable\n        EXPIRED,                     // Order has already expired\n        FULLY_FILLED,                // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    // solhint-enable max-line-length\n\n    struct OrderInfo {\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    /// @dev Calculates Keccak-256 hash of the order.\n    /// @param order The order structure.\n    /// @return Keccak-256 EIP712 hash of the order.\n    function getOrderHash(Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    /// @dev Calculates EIP712 hash of the order.\n    /// @param order The order structure.\n    /// @return EIP712 hash of the order.\n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encodePacked(\n        //     EIP712_ORDER_SCHEMA_HASH,\n        //     bytes32(order.makerAddress),\n        //     bytes32(order.takerAddress),\n        //     bytes32(order.feeRecipientAddress),\n        //     bytes32(order.senderAddress),\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData)\n        // ));\n\n        assembly {\n            // Calculate memory addresses that will be swapped out before hashing\n            let pos1 := sub(order, 32)\n            let pos2 := add(order, 320)\n            let pos3 := add(order, 352)\n\n            // Backup\n            let temp1 := mload(pos1)\n            let temp2 := mload(pos2)\n            let temp3 := mload(pos3)\n            \n            // Hash in place\n            mstore(pos1, schemaHash)\n            mstore(pos2, makerAssetDataHash)\n            mstore(pos3, takerAssetDataHash)\n            result := keccak256(pos1, 416)\n            \n            // Restore\n            mstore(pos1, temp1)\n            mstore(pos2, temp2)\n            mstore(pos3, temp3)\n        }\n        return result;\n    }\n}\n",
        "src/LibEIP712.sol": "/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.5;\n\n\ncontract LibEIP712 {\n\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            uint256(address(this))\n        ));\n    }\n\n    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n    /// @param hashStruct The EIP712 hash struct.\n    /// @return EIP712 hash applied to this EIP712 Domain.\n    function hashEIP712Message(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n        // Assembly for more efficient computing:\n        // keccak256(abi.encodePacked(\n        //     EIP191_HEADER,\n        //     EIP712_DOMAIN_HASH,\n        //     hashStruct    \n        // ));\n\n        assembly {\n            // Load free memory pointer\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n            // Compute hash\n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}\n"
    },
    "sourceTreeHashHex": "0xf52fd5e70efef22ef9ab39fbdf7af3133a026f9791529aebd873f0671920cdcf",
    "compiler": {
        "name": "solc",
        "version": "soljson-v0.5.10+commit.5a6ea5b1.js",
        "settings": {
            "optimizer": {
                "enabled": true,
                "runs": 1000000,
                "details": {
                    "yul": true,
                    "deduplicate": true,
                    "cse": true,
                    "constantOptimizer": true
                }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "devdoc",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap"
                    ]
                }
            },
            "evmVersion": "constantinople",
            "remappings": [
                "@0x/contracts-utils=/Users/fabioberger/Documents/projects/0x_project/0x-monorepo-one/contracts/exchange-libs/node_modules/@0x/contracts-utils"
            ]
        }
    },
    "networks": {}
}
